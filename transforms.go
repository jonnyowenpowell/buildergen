package main

import (
	"strings"
)

// BuildFuncReceiverSuffixes returns a slice of all the necessary suffixes for
// Build methods on the builder for the struct described by desc.
//
// Suffixes are generated by listing the required field names and appending
// every combination, including none, of the optional fields. Field names are
// transformed with [FirstToUpper].
func BuildFuncReceiverSuffixes(desc StructDesc) []string {
	var prefix string
	for _, f := range desc.Fields {
		if !f.Optional {
			prefix += FirstToUpper(f.Name)
		}
	}

	var res []string
	res = append(res, prefix)
	for _, fs := range combinations(desc.Fields, true) {
		res = append(res, prefix+strings.Join(fs, ""))
	}

	return res
}

// PartialBuilderTypeSuffixes returns a slice of all the necessary suffixes for
// partial builder types.
//
// Suffixes are generated by listing all ordered combinations of field names.
// Field names are transformed with [FirstToUpper].
func PartialBuilderTypeSuffixes(desc StructDesc) []string {
	var res []string
	for _, fs := range combinations(desc.Fields, false) {
		res = append(res, strings.Join(fs, ""))
	}

	return res
}

// WithFuncs returns a slice of descriptions of the exported With
// methods on the builder for the struct described by desc.
//
// Every field included in the builder has With methods with receivers of
// every builder type suffixed by a combination of fields excluding itself,
// returning the same combination but including itself.
func WithFuncs(desc StructDesc) []WithFuncDesc {
	var res []WithFuncDesc
	for _, f := range desc.Fields {
		rets := filter(combinations(desc.Fields, false), includingFieldFilter(f))
		for _, ret := range rets {
			rec := filter(ret, notEqFieldFilter(f))
			res = append(res, WithFuncDesc{
				FieldName:      f.Name,
				FieldType:      f.Type,
				ReceiverSuffix: strings.Join(rec, ""),
				ReturnSuffix:   strings.Join(ret, ""),
			})
		}
	}

	return res
}

func filter[T any](s []T, p func(T) bool) []T {
	var res []T
	for _, v := range s {
		if p(v) {
			res = append(res, v)
		}
	}

	return res
}

func includingFieldFilter(f FieldDesc) func([]string) bool {
	return func(names []string) bool {
		for _, n := range names {
			if n == FirstToUpper(f.Name) {
				return true
			}
		}
		return false
	}
}

func notEqFieldFilter(f FieldDesc) func(string) bool {
	return func(n string) bool {
		return n != FirstToUpper(f.Name)
	}
}

func combinations(fs []FieldDesc, optionalOnly bool) [][]string {
	var res [][]string
	if len(fs) == 0 {
		return res
	}
	if len(fs) == 1 {
		if !optionalOnly || fs[0].Optional {
			res = append(res, []string{FirstToUpper(fs[0].Name)})
		}
		return res
	}

	cs := combinations(fs[1:], optionalOnly)

	if !optionalOnly || fs[0].Optional {
		res = append(res, []string{FirstToUpper(fs[0].Name)})
		for _, c := range cs {
			res = append(res, c)
			sc := make([]string, len(c)+1)
			sc[0] = FirstToUpper(fs[0].Name)
			copy(sc[1:], c)
			res = append(res, sc)
		}
	} else {
		res = append(res, cs...)
	}

	return res
}
